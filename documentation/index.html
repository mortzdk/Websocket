<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WSServer: WSServer a C WebSocket Server</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.doxygen.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WSServer
   &#160;<span id="projectnumber">v2.1.0</span>
   </div>
   <div id="projectbrief">C-WebSocket-Server</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">WSServer a C WebSocket Server </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/mortzdk/Websocket"><object type="image/svg+xml" data="https://travis-ci.org/mortzdk/Websocket.svg?branch=master" style="pointer-events: none;">Build Status</object></a> <a href="https://opencollective.com/websocket/"><object type="image/svg+xml" data="https://opencollective.com/websocket/tiers/badge.svg" style="pointer-events: none;">Financial Contributors</object></a></p>
<p>WSServer is a fast, configurable, and extendable WebSocket Server for UNIX systems written in C (C11).</p>
<p>As of version 2.0.0 the WSServer has been completely rewritten with many new features, better support, better extendability and generally as a more stable WebSocket server.</p>
<p>Current Version: <b>v2.1.0</b></p>
<h2>Early history</h2>
<p>The original WebSocket server (v1.0.0 and before) started out as a hobby project in 2012. The idea at the time, was to learn the C language and understand the basics of WebSockets. The initial version of the server worked for some but not all aspects of the protocols present at that time. At that time, different browsers implemented different versions of the WebSocket Protocol, which made it difficult to support all browsers. Today all major browsers support the <a href="http://tools.ietf.org/html/rfc6455">RFC6455</a> protocol, which has been stable for many years.</p>
<h2>Present (2020)</h2>
<p>WSServer now supports all aspects of the <a href="http://tools.ietf.org/html/rfc6455">RFC6455</a> protocol, including the <a href="https://tools.ietf.org/html/rfc7692">RFC7692</a> that enables the <code>permessage-deflate</code> extension. The implementation is verified by the <a href="https://github.com/crossbario/autobahn-testsuite">Autobahn testsuite</a> and by a lot of unit tests. It furthermore support the older protocols <a href="https://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10">HYBI10</a> and <a href="https://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07">HYBI07</a> as there are no noteable difference between those and the current stable one. Currently there are no support for older versions of the protocol.</p>
<h2>Donate</h2>
<p>To support further development on this project and financially support the developer having a nice cup of coffee, you can make a donation of your choice <a href="https://opencollective.com/websocket">here</a>.</p>
<h1>How to get started</h1>
<p>To build the WSServer for your UNIX system, simply run: <code>make release</code>. This will compile extensions, subprotocols, and the binary that will be available from: <code>./bin/WSServer</code>.</p>
<p>Currently the WSServer support only one extension namely the <code>permessage-deflate</code> extension. Read more about this implementation <a href="#Permessage-Deflate">here</a>.</p>
<p>Furthermore it supports two subprotocols: <a href="#Echo">echo</a> and <a href="#Broadcast">broadcast</a>. The <a href="#Echo">echo</a> subprotocol is a simple protocol that sends whatever message received, back to the same client. This is also the default protocol chosen, if no subprotocol is provided by the client. The <a href="#Broadcast">broadcast</a> subprotocol is slightly more advanced. It sends a message from one client to all other connected clients. The behaviour is basically as a public chat room.</p>
<p>The server can be configured by providing a <code>-c [path_to_config_file.json]</code> flag. If no configuration is provided, the server will run with a default configuration, that support WebSocket over HTTP on port 80. You can read more about the structure and description of the configuration file in the <a href="#Configuration">configuration</a> section.</p>
<h3>Log</h3>
<p>WSServer keeps a log file at <code>logs/WSServer.log</code>. The detail of the log is defined by the <code>log_level</code> value in the configuration. Default for a release build is 3 (FATAL, ERROR, WARN, INFO). Default for a test build is 5 (FATAL, ERROR, WARN, INFO, DEBUG, TRACE).</p>
<p>The log file is a good tool for discovering misbehavior of the server, such as when the server isn't able to start, since port 80 is already occupied by another server instance.</p>
<h3>Dependencies</h3>
<p>WSServer does in principle not rely on any third-party libraries in order to serve as a WebSocket server. However if you want the complete feature set the <a href="https://zlib.net/"><b>zlib</b></a> and one of the SSL libraries <a href="https://www.openssl.org/"><b>OpenSSL</b></a>, <a href="https://www.wolfssl.com/"><b>WolfSSL</b></a>, <a href="https://www.boringssl.googlesource.com/boringssl/"><b>BoringSSL</b></a>, <a href="https://www.libressl.org/"><b>LibreSSL</b></a> must be installed on your system in order to support the <code>permessage-deflate</code> extension and SSL (WSS).</p>
<h5>Ubuntu</h5>
<div class="fragment"><div class="line">$ sudo apt-get install zlib1g-dev</div>
<div class="line">$ sudo apt-get install openssl</div>
<div class="line">$ sudo apt-get install wolfssl</div>
</div><!-- fragment --><h5>Arch</h5>
<div class="fragment"><div class="line">$ pacman -S zlib</div>
<div class="line">$ pacman -S wolfssl</div>
<div class="line">$ pacman -S libressl</div>
</div><!-- fragment --><h5>MacOS</h5>
<div class="fragment"><div class="line">$ brew install zlib</div>
<div class="line">$ brew install openssl</div>
<div class="line">$ brew install wolfssl</div>
</div><!-- fragment --><h5>FreeBSD</h5>
<div class="fragment"><div class="line">$ pkg install libressl</div>
<div class="line">$ pkg install boringssl</div>
<div class="line">$ pkg install openssl</div>
<div class="line">$ pkg install zlib</div>
</div><!-- fragment --><p>If the installation method is not listed above or your package manager doesn't contain the software, it can all be build from source.</p>
<p>No other dependencies are required with regards to building the server with the full feature set.</p>
<p>If you want to run the <a href="https://github.com/crossbario/autobahn-testsuite">Autobahn testsuite</a> and the unit tests yourself, further dependencies are required. These are <a href="https://www.docker.com/"><b>docker</b></a> and <a href="https://github.com/Snaipe/Criterion"><b>criterion</b></a>.</p>
<h5>Ubuntu</h5>
<div class="fragment"><div class="line">$ sudo apt install docker.io</div>
<div class="line">$ sudo add-apt-repository ppa:snaipewastaken/ppa</div>
<div class="line">$ sudo apt-get update</div>
<div class="line">$ sudo apt-get install criterion-dev</div>
</div><!-- fragment --><h5>Arch</h5>
<div class="fragment"><div class="line">$ pacman -S docker</div>
<div class="line">$ pacman -S criterion</div>
</div><!-- fragment --><h5>MacOS</h5>
<div class="fragment"><div class="line">$ brew install docker</div>
<div class="line">$ brew install snaipe/soft/criterion</div>
</div><!-- fragment --><h5>FreeBSD</h5>
<div class="fragment"><div class="line">$ pkg install docker</div>
</div><!-- fragment --><p>Criterion can be build for FreeBSD using the following <a href="https://criterion.readthedocs.io/en/latest/setup.html#installation">guide</a>. <br  />
</p>
<h3>Configuration</h3>
<p>An example of a configuration file can be found at <a href="https://github.com/mortzdk/Websocket/blob/master/conf/wss.json">here</a>. A lot of different things are configurable through the configuration file.</p>
<h5>Origins</h5>
<p>The <code>origins</code> key define a subset of allowed origins. It is always recommended to define this subset. In case no subset is defined a client can connect from anywhere.</p>
<h5>WebSocket URI</h5>
<p>A WebSocket URI consists of a <em>scheme</em>, <em>host</em>, <em>port</em>, <em>path</em> and a <em>query</em>. Take for example:</p>
<p><b>wss://mortz.dk:9011/websocket?csrf-token=asgjh48hs389hdla</b>.</p>
<p>The <b>wss</b> part of the URI is defined as the <em>scheme</em>, the <b>mortz.dk</b> part is defined as the host, the <b>9011</b> part is defined as the <em>port</em>, the **/websocket** part is defined as the <em>path</em> and the <b>?csrf-token=asgjh48hs389hdla</b> part is defined as the <em>query</em>. The specific allowance of all 5 parts of the WebSocket URI are configurable.</p>
<p>The <code>hosts</code> key define a subset of strings allowed as the host. In the example above, if we only want clients connecting to <b>mortz.dk</b>, we can add that string to the subset.</p>
<p>The <code>paths</code> key define a subset of strings allowed as the connecting path. In the example above, if we only want clients connecting through the path **/websocket**, we can add that string to the subset. The path **/** will always be a valid connection path. The string values of the <code>paths</code> key are allowed to use POSIX Extended Regular Expressions syntax.</p>
<p>The <code>queries</code> key define a subset of strings allowed as the queries. In the example above, if we only want clients to use a specific query <b>csrf-token=[^&amp;]*</b>, we can add that string to the subset. The string values of the <code>paths</code> key are allowed to use POSIX Extended Regular Expressions syntax. A WebSocket URI without any queries is always allowed.</p>
<p>The <em>scheme</em> and <em>port</em> part of the WebSocket URI is checked based on the ports choosen for <code>http</code> and <code>https</code>.</p>
<h5>Port</h5>
<p>The <code>port</code> key of the <code>setup</code> object is used to define the ports that http (ws) version and the https (wss) should be listening to.</p>
<p>A http (ws) version of the server will always be available. The https (wss) version requires further configuration of SSL.</p>
<h5>Extensions</h5>
<p>The <code>extensions</code> key of the <code>setup</code> object is used to define an array of supported extensions. Each entry in the array is an object itself containing a <code>file</code> and <code>config</code> key. The <code>file</code> key should point to the location of the shared object representing the extension. The basename of the <code>file</code> key is used as the extension name. The <code>config</code> key can be used to provide extra configuration to the extension.</p>
<h5>Subprotocols</h5>
<p>The <code>subprotocols</code> key of the <code>setup</code> object is used to define an array of supported subprotocols. Each entry in the array is an object itself containing a <code>file</code> and <code>config</code> key. The <code>file</code> key should point to the location of the shared object representing the subprotocol. The basename of the <code>file</code> key is used as the subprotocol name. The <code>config</code> key can be used to provide extra configuration to the subprotocol.</p>
<h5>Favicon</h5>
<p>The <code>favicon</code> key of the <code>setup</code> object is used to define a favicon to serve for HTTP and HTTPS request. A lot of browsers do the request for favicons per default when performing HTTP and HTTPS requests. By defining this with the path to a valid ICO file, the WSServer will return a favicon.</p>
<h5>Timeouts</h5>
<p>The <code>timeout</code> key of the <code>setup</code> object is used to define different timeouts of the WSServer.</p>
<p>The <code>poll</code> key define a timeout for event polling. By setting it to a positive integer <b>n</b>, the event loop will be interrupted every <b>n</b> milliseconds.</p>
<p>The <code>read</code> key define a timeout for the READ event. The timeout is checked whenever the server requires to read more data from the client in order to succeed. By setting it to a positive integer <b>n</b> the request will fail if the next read took longer than <b>n</b> milliseconds.</p>
<p>The <code>write</code> key define a timeout for the WRITE event. The timeout is checked whenever the server requires to write more data to the client than it is currently able to buffer. By setting it to a positive integer <b>n</b> the request will fail if the next write took longer than <b>n</b> milliseconds.</p>
<p>The <code>client</code> key define a timeout for when the client was last active. By setting it to a positive <b>n</b> integer, the client will be disconnected if it has not been active the last <b>n</b> milliseconds.</p>
<p>The <code>pings</code> key defines the amount of pings performed within the span of the <code>client</code> timeout key. If this value is set, it is recommended to use a value stricly higher than 1, as the internal timing of the server is not 100% accurate.</p>
<h5>Size</h5>
<p>A lot of different sizes can be adjusted for the WSServer. All sizes but the <code>ringbuffer</code> are defined in bytes.</p>
<p>The <code>payload</code> size define how large a size of payload the server is willing to accept from the client.</p>
<p>The <code>header</code> size define how large a HTTP header the server will accept from the client.</p>
<p>The <code>uri</code> size define how large a URI the server will accept from the client.</p>
<p>The <code>buffer</code> size define how large the internal read and write buffers should be.</p>
<p>The <code>thread</code> size define how large each thread of the WSServer can maximally be.</p>
<p>The <code>ringbuffer</code> size define how many messages about to be written each client can store in their ringbuffer.</p>
<p>The <code>frame</code> size define the maximal payload size of a single frame.</p>
<p>The <code>fragmented</code> size define how many fragments (frames) one single message can consist of.</p>
<h5>Pool</h5>
<p>Internally the WSServer runs a threadpool to schedule IO work from the clients.</p>
<p>The <code>worker</code> key define the amount of threads the threadpool shall consist of. Generally the rule of thumb is that the higher the load, the more threads. However the optimal amount of workers is probably system and hardware dependent.</p>
<h5>SSL (WSS)</h5>
<p>WSServer supports the <em>wss</em> scheme by the use of one of currently 4 SSL libraries (<a href="https://www.openssl.org/"><b>OpenSSL</b></a>, <a href="https://www.wolfssl.com/"><b>WolfSSL</b></a>, <a href="https://www.boringssl.googlesource.com/boringssl/"><b>BoringSSL</b></a>, <a href="https://www.libressl.org/"><b>LibreSSL</b></a>). The default choice is OpenSSL, but the SSL library can be switched as follows:</p>
<div class="fragment"><div class="line"># OpenSSL</div>
<div class="line">$ make</div>
<div class="line"> </div>
<div class="line"># WolfSSL</div>
<div class="line">$ make SSL=WOLFSSL</div>
<div class="line"> </div>
<div class="line"># LibreSSL</div>
<div class="line">$ make SSL_LIBRARY_PATH=/path/to/libressl</div>
<div class="line"> </div>
<div class="line"># BoringSSL</div>
<div class="line">$ make SSL_LIBRARY_PATH=/path/to/boringssl</div>
</div><!-- fragment --><p>Note that if compiled with <code>SSL_LIBRARY_PATH</code> the binary must be executed with <code>LD_LIBRARY_PATH=/path/to/libressl/lib ./bin/WSServer</code>.</p>
<p>If LibreSSL or BoringSSL is installed in place of OpenSSL the compilation should work out of the box by running <code>make</code>.</p>
<p>In order to activate SSL some configuration must be made.</p>
<p>The <code>key</code> key define the path to the SSL private key of the server. The private key must be in the PEM format.</p>
<p>The <code>cert</code> key define the path to the SSL server certificate. The certificate must be in the PEM format.</p>
<p>The <code>ca_file</code> key define the path to the root CA certificate.</p>
<p>The <code>ca_path</code> key define the path to a folder containing the trusted root CA certifates.</p>
<p>The <code>dhparam</code> key define the path to the dhparam file. The dhparam file must be in the PEM format.</p>
<p>The <code>cipher_list</code> key define the ciphers that the server allows usage of.</p>
<p>The <code>cipher_suites</code> key define the cipher suites that the server allows usage of.</p>
<p>The <code>compression</code> key define whether compression should be used when communicating over SSL,</p>
<p>The <code>peer_cert</code> key define whether a peer certificate is required by the client.</p>
<h1>WebSocket Extensions</h1>
<p>The WSServer enables usage of an arbitrary number of extensions. Extensions provide a mechanism for implementations to opt-in to additional protocol features.</p>
<p>The extensions themselves can be implemented in any language that is able to compile into a shared object (*.so* file) with the following public functions:</p>
<div class="fragment"><div class="line">typedef void (*setAllocators)(WSS_malloc_t extmalloc, WSS_realloc_t extrealloc, WSS_free_t extfree);</div>
<div class="line">typedef void (*onInit)(char *config);</div>
<div class="line">typedef void (*onOpen)(int fd, char *param, char **accepted, bool *valid);</div>
<div class="line">typedef void (*inFrame)(int fd, wss_frame_t *frame);</div>
<div class="line">typedef void (*inFrames)(int fd, wss_frame_t **frames, size_t len);</div>
<div class="line">typedef void (*outFrame)(int fd, wss_frame_t *frame);</div>
<div class="line">typedef void (*outFrames)(int fd, wss_frame_t **frames, size_t len);</div>
<div class="line">typedef void (*onClose)(int fd);</div>
<div class="line">typedef void (*onDestroy)();</div>
</div><!-- fragment --><p>Where <code>WSS_malloc_t</code>, <code>WSS_realloc_t</code>, and <code>WSS_free_t</code> are defined as:</p>
<div class="fragment"><div class="line">typedef void *(*WSS_malloc_t)(size_t size);</div>
<div class="line">typedef void *(*WSS_realloc_t)(void *ptr, size_t size);</div>
<div class="line">typedef void (*WSS_free_t)(void *ptr);</div>
</div><!-- fragment --><p>and <code>wss_frame_t</code> is defined as:</p>
<div class="fragment"><div class="line">typedef struct {</div>
<div class="line">    bool fin;</div>
<div class="line">    bool rsv1;</div>
<div class="line">    bool rsv2;</div>
<div class="line">    bool rsv3;</div>
<div class="line">    uint8_t opcode;</div>
<div class="line">    bool mask;</div>
<div class="line">    uint64_t payloadLength;</div>
<div class="line">    char maskingKey[4];</div>
<div class="line">    char *payload;</div>
<div class="line">    uint64_t extensionDataLength;</div>
<div class="line">    uint64_t applicationDataLength;</div>
<div class="line">} wss_frame_t;</div>
</div><!-- fragment --><p>For the server to be able to use a custom extension one has to configure the path to the shared object in the configuration file as described <a href="#Extensions">above</a>.</p>
<p>You can have a look at the <a href="https://github.com/mortzdk/websocket/blob/master/extensions">extensions</a> folder to see how to implement your own extension.</p>
<h3>Permessage-deflate</h3>
<p>The WSServer comes with 1 build-in extension, namely the <code>permessage-deflate</code> extension defined in <a href="https://tools.ietf.org/html/rfc7692">RFC7692</a>. This extension enables compression and decompression of the frames between client and server.</p>
<h1>WebSocket Subprotocols</h1>
<p>The WSServer also enables usage of an arbitrary number of subprotocols. Subprotocols are application-level protocol layered over the WebSocket Protocol that are used to define the behaviour of the websocket protocol.</p>
<p>The subprotocols themselves can be implemented in any language that is able to compile into a shared object (*.so* file) with the following public functions:</p>
<div class="fragment"><div class="line">typedef void (*setAllocators)(WSS_malloc_t submalloc, WSS_realloc_t subrealloc, WSS_free_t subfree);</div>
<div class="line">typedef void (*onInit)(char *config, WSS_send send);</div>
<div class="line">typedef void (*onConnect)(int fd, char *ip, int port, char *path, char *cookies);</div>
<div class="line">typedef void (*onMessage)(int fd, wss_opcode_t opcode, char *message, size_t message_length);</div>
<div class="line">typedef void (*onWrite)(int fd, char *message, size_t message_length);</div>
<div class="line">typedef void (*onClose)(int fd);</div>
<div class="line">typedef void (*onDestroy)();</div>
</div><!-- fragment --><p>Where <code>WSS_send</code>, <code>WSS_malloc_t</code>, <code>WSS_realloc_t</code>, and <code>WSS_free_t</code> are defined as:</p>
<div class="fragment"><div class="line">typedef void (*WSS_send)(int fd, wss_opcode_t opcode, char *message, uint64_t message_length);</div>
<div class="line">typedef void *(*WSS_malloc_t)(size_t size);</div>
<div class="line">typedef void *(*WSS_realloc_t)(void *ptr, size_t size);</div>
<div class="line">typedef void (*WSS_free_t)(void *ptr);</div>
</div><!-- fragment --><p>and <code>wss_opcode_t</code> is defined as:</p>
<div class="fragment"><div class="line">typedef enum {</div>
<div class="line">    CONTINUATION_FRAME = 0x0,</div>
<div class="line">    TEXT_FRAME         = 0x1,</div>
<div class="line">    BINARY_FRAME       = 0x2,</div>
<div class="line">    CLOSE_FRAME        = 0x8,</div>
<div class="line">    PING_FRAME         = 0x9,</div>
<div class="line">    PONG_FRAME         = 0xA,</div>
<div class="line">} wss_opcode_t;</div>
</div><!-- fragment --><p>You can have a look at the <a href="https://github.com/mortzdk/websocket/blob/master/extensions">subprotocols</a> folder to see how to implement your own subprotocol.</p>
<h3>Client Authentication</h3>
<p>Client authentication is not implemented directly in WSServer, but is supported through several means. The <code>onConnect</code> call of the subprotocol sends information about the connection to the subprotocol, this is information such as the <em>ip</em>, <em>port</em>, <em>path</em> and <em>cookies</em>. This can be used to do client authentication using <a href="https://coletiv.com/blog/using-websockets-with-cookie-based-authentication/">cookies</a>, using query parameters of the path or simply by having an initial round of authentication messages between the client and server.</p>
<p>As always it is strongly advised to use the <a href="#Origins">origins</a> array of the configuration to only allow for certain origins to use the server.</p>
<h3>Echo</h3>
<p>The <code>echo</code> subprotocol is a very simple subprotocol that just echo's whatever the client send back to the client. This subprotocol is especially useful for testing and is used in the <a href="https://github.com/crossbario/autobahn-testsuite">Autobahn testsuite</a>.</p>
<h3>Broadcast</h3>
<p>The <code>broadcast</code> subprotocol is slightly more advanced. It keeps track of when a client is connecting or closing in order to hold a map of those clients that should be broadcastet to. Whenever a client sends a message, the message is broadcastet to all other connected clients.</p>
<h1>Documentation</h1>
<p>WSServer automatically generates documentation based on the comments in the code. This documentation can be viewed <a href="https://mortzdk.github.io/Websocket/documentation/">here</a>.</p>
<p>Furthermore one could take a look at the <a href="http://tools.ietf.org/html/rfc6455">RFC6455</a> protocol and the <a href="https://tools.ietf.org/html/rfc7692">RFC7692</a> protocol to understand how WebSockets and the permessage-deflate extension works.</p>
<h1>Testing</h1>
<p>WSServer has been heavily tested by the use of unit tests, the <a href="https://github.com/crossbario/autobahn-testsuite">Autobahn testsuite</a> and by having code coverage.</p>
<h3>Unit tests</h3>
<p>A lot of unit tests has been written using the <a href="https://github.com/Snaipe/Criterion">Criterion</a> unit testing library. As of right now the unit tests does not cover all files, and this is still work in progress.</p>
<p>The tests can be run by running <code>make test</code>.</p>
<h3>Autobahn Testsuite</h3>
<p>The Autobahn Testsuite is used to verify that the WSServer complies to the <a href="http://tools.ietf.org/html/rfc6455">RFC6455</a> protocol. These tests can be used as both verification and as a measure of performance as a lot of the tests actually times the execution of a successful test.</p>
<p>The tests can be run by running <code>make autobahn</code>.</p>
<p>You can further see the current results of the tests <a href="https://mortzdk.github.io/Websocket/autobahn/">here</a>.</p>
<h3>Code coverage</h3>
<p>The coverage report can be generated by running <code>make test</code> and the latest can be seen <a href="https://mortzdk.github.io/Websocket/gcov/">here</a>.</p>
<h1>Further Work</h1>
<p>Here is a list of prioritized further work that currently can be done:</p>
<ol type="1">
<li>Test on FreeBSD/MacOS</li>
<li>Use Autoconf to check dependencies</li>
<li>Rate limiting<ul>
<li>Rate limiting connections<ul>
<li>Count-Min Sketch (Sliding window)<ul>
<li>Belongs to the server object</li>
<li>Allocate 60 count-min sketches (one per minute)</li>
<li>Reset sketch if rotated</li>
</ul>
</li>
</ul>
</li>
<li>Rate limiting messages<ul>
<li>Can be done by the subprotocols per message?</li>
</ul>
</li>
<li>Rate limiting frames<ul>
<li>Counting using Sliding window<ul>
<li>Belongs to the session object</li>
<li>Allocate 60 integers (one per minute)</li>
<li>Reset sketch if rotated</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Fuzz testing</li>
<li>Support HTTP2</li>
<li>Performance Improvements<ul>
<li>Look at 'khash' or 'tommy_hashdyn' instead of 'uthash' since these hashes seems to be faster</li>
<li>Realloc the double size of the current</li>
<li>Refactor <code>wss_frame_t</code> structure away. Use the frames as byte strings instead.</li>
<li>Callgrind</li>
<li>Cachegrind</li>
</ul>
</li>
<li>Backwards Specification Compability<ul>
<li>hybi-06</li>
<li>hybi-05</li>
<li>hybi-04</li>
<li>hixie-76</li>
<li>hixie-75</li>
</ul>
</li>
</ol>
<h1>Contributors</h1>
<p>Here is a list of the contributors of v2.0.0 and above of the WSServer.</p>
<p><a href="https://github.com/mortzdk/">Morten Houm√∏ller Nygaard</a> <a href="https://github.com/babelouest/">Nicolas Mora</a></p>
<h3>Libraries</h3>
<p>WSServer makes use of other Open-Source libraries and code snippets. The links listed below have all been used in some way.</p>
<ul>
<li><a href="https://github.com/lemire/fastvalidate-utf-8/">Fast Validation of UTF-8</a></li>
<li><a href="http://bjoern.hoehrmann.de/utf-8/decoder/dfa/">UTF-8 Decoder</a></li>
<li><a href="https://tools.ietf.org/html/rfc3174">SHA1</a></li>
<li><a href="https://github.com/rmind/ringbuf">Ringbuf</a></li>
<li><a href="https://github.com/rxi/log.c">log.c</a></li>
<li><a href="https://github.com/littlstar/b64.c">b64.c</a></li>
<li><a href="https://github.com/mjansson/rpmalloc">rpmalloc</a></li>
<li><a href="https://github.com/mbrossard/threadpool">Threadpool</a></li>
<li><a href="https://github.com/udp/json-parser">json-parser</a></li>
<li><a href="https://troydhanson.github.io/uthash/">uthash</a></li>
<li><a href="https://github.com/j-ulrich/http-status-codes-cpp">Http Status Codes</a></li>
</ul>
<h1>License</h1>
<p>WSServer is licenced under the <a href="https://github.com/mortzdk/Websocket/blob/master/LICENSE">MIT license</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
